<!doctype html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Journeyman Blog</title>
	<link rel="stylesheet" href="style.css">
</head>
<body>
<h2>Week 1</h2>
<p>25/01 - 31/01</p>
<p>
The main focus of the first week was figuring out which of the three games we
would work on. Being a programmer, I spent most of the week on gameplay and
mechanics research for those three games, to figure out which was the most
interesting, and which we could expand on. We also had descussions as a team
to try and figure out which game would be the best to work on for us and in
the end decided to go with Castlevania.
</p>
<h2>Week 2</h2>
<p>01/02 - 07/02</p>
<p>
Now that we knew we were going with Castlevania as our base game, we decided
to spend the second week figuring out the setting, themes, and mechanics that
we would change and expand on. In the end, we decided to go with a Sci-fi
setting, and set the game on a space ship, so some of the mechanics I did
research on was low gravity, adding turrets, and having futuristic elemental
weapons.
</p>
<h2>Week 3</h2>
<p>08/02 - 14/02</p>
<p>
Having done mechanics research, we were almost ready to start implementing
them in UE4, but because we lacked experience with blueprints, we decided to
start with smaller assets that would be quicker to implement, thus allowing
us to quickly learn the basics. We had a call amongst the programmer to
where I assigned them the mechanics they would have to implement, we also
discussed how to integrate Git into our workflows. Through this discussion,
we learnt about the built in Git plugin in UE4, which allowed us to see
individual changes to the assets.
</p>
<h2>Week 4</h2>
<p>15/02 - 21/02</p>
<p>
This weeks goal was to merge our individual work into the development branch.
At first we though that it would be easy using the git plugin for UE4, but
having tried it, we realised that it would not work, as it doesn't allow you
to to merge individual differences, only the source or the target. This got
looking for alternatives, and our final decision was to move the blueprints
to seperate components. This would allow us to break the logic into smaller
chunks, meaning that we wouldn't lose work through merging.
</p>
<p>
Since we had to present our work this week, I had a session with the other
leads to create a presentation, and to rehearse it.
</p>
<h2>Week 5</h2>
<p>22/02 - 28/02</p>
<p>
This week I personally have been working on updating and refining the player
movement mechanic as we recieved some feedback pointing out how it could be
improved. The issue was that the player would keep jumping while holding the
key, which the game designers didn't like and so we decided to remove it. This
was done by checking if the key was pressed this frame, rather than if the key
was held.
</p>
<p>
As the lead programmer for this project, I have also been responsible for
managing the other programmers, making sure they have features to work on, and
also acting as a point of communication between the other diciplines. The way I
decided to distribute the work amongst the team was by organising it by
importance, and then going over each feature and allowing the programmers to
choose them based on their proficencies. Stefan now will be focusing on the
enemy AI movement, while Sam is going to be implementing the camera movement.
</p>
<h2>Week 6</h2>
<p>01/03 - 07/03</p>
<p>
One of the biggest features that we had to implement was the combat. On top of
that we wanted to have a few different weapons at the player's disposal, both
melee and ranged. This meant that we had to implement some sort of inventory
system, and I decided to work on it as I had a lot of experience implementing
inventory systems in previous projects. I decided to go with a fairly basic
system that only kept track of whether you had picked up the weapon to keep it
simple. One of the requirements of the inventory system was to persist between
levels, meaning that weapons picked up in Level 1 could be used in Level 2. To
implement this I decided to use a custom Game Instance which is a class that
isn't destroyed between levels, so is usefull for keeping track of variables
like health, score and in my case the weapons the player has picked up.
</p>
<h2>Week 7</h2>
<p>08/03 - 14/03</p>
<p>
To supplement the inventory system that I got working last week, my task this
week was to create a pickup system that so the player can pickup weapons. By
using a more generalised approach, I could also create pickups for health,
ammo, and powerups. The first part of creating a pickup was getting the player
to interact with it. I did this by creating a sphere trigger around the pickup,
which once entered allowed the player to press a key and interact with the
pickup, destroying it in the process. Now that I had the basic functionality of
the pickup working, the second part was creating different pickups. All that a
weapon pickup would have to do is toggle a boolean that kept track of if the
weapon had been picked up, and so it fairly simple to implement. I also ended
up adding a health pickup.
</p>
<h2>Week 8</h2>
<p>15/03 - 21/03</p>
<p>
This week the focus has been on getting another build out to the rest of the
team, so they can play the updated game and see the progress we've made so far,
and to bring up any issues with the gameplay. This means that we first have to
merge all the different branches that we've been working into a single 'dev'
branch. Unreal Engine makes this quite painful becaues all the files are
binary, meaning changes between them can't be integrated meaning all the
conflicts we have to resolve manually which takes a lot of time as we basically
have to recreate the files that have conflicts. While this can be mitigated
somewhat through using components, it isn't perfect but we did get everything
merged by the end of the week. Once we had everything merged we had to create a
playground level to showcase all the mechanics we've implemented so far. Once
this was all done, we built the game and put it in our Discord server for
everyone to playtest. By the end of the week, we had quite a lot of feedback to
go through and implement.
</p>
<h2>Week 9</h2>
<p>22/03 - 28/03</p>
<p>
This week we focused on getting the feedback implemented into the game, since I
was responsible for the player movement, I focused for adding tweaks to it. The
biggest was a bug that allowed triggers to reset the player's jump, meaning he
could jump in mid air. This meant that I had to redesing the way I checked if
the player was on the floor to ignore triggers. They way I solved the problem
was by comparing the physics profile of the other object, and ignoring it if
it's a trigger.
</p>
<h2>Week 10</h2>
<p>29/03 - 04/04</p>
<p>
The focus of this week has been getting attacking to work. The first step was
creating a trigger in front of the player that detected enemies, the size of
the trigger also had to change depending on the range of the weapon to make the
gameplay more interesting. Once I had the trigger moving and changing size, I
had to make it detect enemies, and I did that by checking if the colliding
entity had a health component. This more generalised approach allows the player
to attack anything that has health, rather than being limited to enemies, so
stuff like crates that drop powerups could be implemented. I kept track of all
the entities colliding in a list, so when the player presses the attack button,
I can iterate over the content and damage each entity, allowing the player to
hit multiple enemies.
</p>
<h2>Week 11</h2>
<p>05/04 - 11/04</p>
<p>
To improve on the attacking mechanic that I implemented last week, I decided to
add an invincibility timer to all entities, this would fix one of the biggest
issues with combat which was the ability to spam attack enemies. This had to be
done in the health component, which would mean every entity that had health,
would now also have an invincibility timer which could be adjusted which was a
nice bouns. The problem was that all the health changing happened in one
function which meant that there was no reliable way of knowing if the entity
should be invincible. I solved this by splitting the fuction into a heal and a
hurt function. This meant that invincibility would only be triggered after an
entity gets hurt, and that healing could bypass invincibility. But it also
meant I had to update all the scripts that interfaced with the health
component, allowing them to use the new functions, and after I had done it,
everything was working well.
</p>
<h2>Week 12</h2>
<p>12/04 - 18/04</p>
<p>
This week I've been focusing on my other module as I've neglected it over the
last couple weeks as I've been mainly focusing on this module, both working on
implementing features and managing the rest of the team that I haven't had a
proper time to work on other stuff. While I still kept the rest of the team up
to date and created a presentation with the other leads, this week I haven't
been working on implementing mechanics.
</p>
<h2>Week 13</h2>
<p>19/04 - 25/04</p>
This week is 
<p>
</p>
<h2>Week 14</h2>
<p>26/04 - 02/05</p>
</body>
</html>
